C51 COMPILER V8.08   KEYBOARD                                                              05/29/2017 18:18:30 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE KEYBOARD
OBJECT MODULE PLACED IN ..\output\keyboard.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\source\keyboard.c BROWSE DEBUG OBJECTEXTEND PRINT(.\keyboard.lst) OBJECT
                    -(..\output\keyboard.obj)

line level    source

   1          #define _KEYBOARD_C
   2          #include "config.h"
   3          #include "keyboard.h"
   4          #include "time.h"
   5          
   6          bit flag200ms = 0;
   7          bit flag1s = 0;
   8          
   9          uint8 T0RH = 0;
  10          uint8 T0RL = 0;
  11          
  12          uint8 pdata keySta[4][4]={
  13                  {1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}
  14          };
  15          
  16          uint8 code keyCodeMap[4][4] = { //矩阵按键编号到标准键盘键码的映射表
  17              { 0x31, 0x32, 0x33, 0x26 }, //数字键1、数字键2、数字键3、向上键
  18              { 0x34, 0x35, 0x36, 0x25 }, //数字键4、数字键5、数字键6、向左键
  19              { 0x37, 0x38, 0x39, 0x28 }, //数字键7、数字键8、数字键9、向下键
  20              { 0x30, 0x1B, 0x0D, 0x27 }  //数字键0、ESC键、  回车键、 向右键
  21          };
  22          
  23          void ClearTremble()
  24          {
  25   1              uint8 i;
  26   1              static uint8 queue = 0; 
  27   1      
  28   1              static uint8 pdata state[4][4] = 
  29   1              {
  30   1                      {0x0F,0x0F,0x0F,0x0F},
  31   1                      {0x0F,0x0F,0x0F,0x0F},
  32   1                      {0x0F,0x0F,0x0F,0x0F},
  33   1                      {0x0F,0x0F,0x0F,0x0F}
  34   1              };
  35   1      
  36   1              switch(queue)
  37   1              {
  38   2                      case 0:KeyOut4 = 1;KeyOut1 = 0;break;
  39   2                      case 1:KeyOut1 = 1;KeyOut2 = 0;break;
  40   2                      case 2:KeyOut2 = 1;KeyOut3 = 0;break;
  41   2                      case 3:KeyOut3 = 1;KeyOut4 = 0;break;
  42   2                      default:break;
  43   2              }
  44   1      
  45   1              state[queue][0] = (state[queue][0] << 1) | KeyIn1;
  46   1              state[queue][1] = (state[queue][1] << 1) | KeyIn2;
  47   1              state[queue][2] = (state[queue][2] << 1) | KeyIn3;
  48   1              state[queue][3] = (state[queue][3] << 1) | KeyIn4;
  49   1      
  50   1              for(i = 0; i < 4; i++)
  51   1              {
  52   2                      if((state[queue][i] & 0x0F) == 0x0F)
  53   2                      {
  54   3                              keySta[queue][i] = 1; 
C51 COMPILER V8.08   KEYBOARD                                                              05/29/2017 18:18:30 PAGE 2   

  55   3                      }else if((state[queue][i] & 0x0F) == 0x00){
  56   3                              keySta[queue][i] = 0;
  57   3                      }else{
  58   3                      }
  59   2              }
  60   1      
  61   1              queue++;
  62   1              queue &= 0x03;
  63   1      }
  64          
  65          void KeyDriver()
  66          {
  67   1              static uint8 pdata keyBuf[4][4]={
  68   1                      {1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1} 
  69   1              };
  70   1              uint8 i,j;
  71   1      
  72   1              for(i = 0; i < 4; i++)
  73   1              {
  74   2                      for(j = 0; j < 4; j++)
  75   2                      {
  76   3                              if(keyBuf[i][j] != keySta[i][j])
  77   3                              {
  78   4                                      if(keyBuf[i][j] == 0x00)
  79   4                                      {
  80   5                                              KeyAction(keyCodeMap[i][j]);
  81   5                                      }
  82   4                                      keyBuf[i][j] = keySta[i][j];
  83   4                              }
  84   3                      }
  85   2              }       
  86   1      }
  87          
  88          void ConfigTimerZero(uint8 ms)
  89          {
  90   1              uint16 tmp;
  91   1      
  92   1              tmp = 65536 - SYS_CLK/1000*ms + 18;
  93   1      
  94   1              T0RH = (uint8)(tmp >> 8);
  95   1              T0RL = (uint8)(tmp & 0x0F);
  96   1      
  97   1              TMOD &= 0xF0;
  98   1              TMOD |= 0x01;
  99   1      
 100   1              TH0 = T0RH;
 101   1              TL0 = T0RL;
 102   1      
 103   1              TR0 = 1;
 104   1              ET0 = 1;
 105   1      }
 106          
 107          void InterruptTimerZero() interrupt 1
 108          {
 109   1              static uint8 cnt200ms = 0, cnt1s = 0;
 110   1      
 111   1              TH0 = T0RH;
 112   1              TL0 = T0RL;
 113   1      
 114   1              cnt200ms++;                     
 115   1              if(cnt200ms >= 200) //200ms定时器
 116   1              {
C51 COMPILER V8.08   KEYBOARD                                                              05/29/2017 18:18:30 PAGE 3   

 117   2                      cnt200ms = 0;
 118   2                      flag200ms = 1;
 119   2                      cnt1s++;                //1s定时器
 120   2                      if(cnt1s >= 5)
 121   2                      {
 122   3                              cnt1s = 0;
 123   3                              flag1s = 1;
 124   3                      }
 125   2              }
 126   1              ClearTremble();
 127   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    435    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     48    ----
   DATA SIZE        =      5       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
