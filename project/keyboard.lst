C51 COMPILER V8.08   KEYBOARD                                                              05/31/2017 16:34:26 PAGE 1   


C51 COMPILER V8.08, COMPILATION OF MODULE KEYBOARD
OBJECT MODULE PLACED IN ..\output\keyboard.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\source\keyboard.c BROWSE DEBUG OBJECTEXTEND PRINT(.\keyboard.lst) OBJECT
                    -(..\output\keyboard.obj)

line level    source

   1          #define _KEYBOARD_C
   2          #include "config.h"
   3          #include "keyboard.h"
   4          #include "time.h"
   5          
   6          bit flag200ms = 0;
   7          bit flag1s = 0;
   8          bit flag5s = 0;
   9          
  10          uint8 T0RH = 0;
  11          uint8 T0RL = 0;
  12          
  13          uint8 pdata keySta[4][4]={
  14                  {1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}
  15          };
  16          
  17          uint8 code keyCodeMap[4][4] = { //矩阵按键编号到标准键盘键码的映射表
  18              { 0x31, 0x32, 0x33, 0x26 }, //数字键1、数字键2、数字键3、向上键
  19              { 0x34, 0x35, 0x36, 0x25 }, //数字键4、数字键5、数字键6、向左键
  20              { 0x37, 0x38, 0x39, 0x28 }, //数字键7、数字键8、数字键9、向下键
  21              { 0x30, 0x1B, 0x0D, 0x27 }  //数字键0、ESC键、  回车键、 向右键
  22          };
  23          
  24          void ClearTremble()
  25          {
  26   1              uint8 i;
  27   1              static uint8 queue = 0; 
  28   1      
  29   1              static uint8 pdata state[4][4] = 
  30   1              {
  31   1                      {0x0F,0x0F,0x0F,0x0F},
  32   1                      {0x0F,0x0F,0x0F,0x0F},
  33   1                      {0x0F,0x0F,0x0F,0x0F},
  34   1                      {0x0F,0x0F,0x0F,0x0F}
  35   1              };
  36   1      
  37   1              switch(queue)
  38   1              {
  39   2                      case 0:KeyOut4 = 1;KeyOut1 = 0;break;
  40   2                      case 1:KeyOut1 = 1;KeyOut2 = 0;break;
  41   2                      case 2:KeyOut2 = 1;KeyOut3 = 0;break;
  42   2                      case 3:KeyOut3 = 1;KeyOut4 = 0;break;
  43   2                      default:break;
  44   2              }
  45   1      
  46   1              state[queue][0] = (state[queue][0] << 1) | KeyIn1;
  47   1              state[queue][1] = (state[queue][1] << 1) | KeyIn2;
  48   1              state[queue][2] = (state[queue][2] << 1) | KeyIn3;
  49   1              state[queue][3] = (state[queue][3] << 1) | KeyIn4;
  50   1      
  51   1              for(i = 0; i < 4; i++)
  52   1              {
  53   2                      if((state[queue][i] & 0x0F) == 0x0F)
  54   2                      {
C51 COMPILER V8.08   KEYBOARD                                                              05/31/2017 16:34:26 PAGE 2   

  55   3                              keySta[queue][i] = 1;
  56   3                      }else if((state[queue][i] & 0x0F) == 0x00){
  57   3                              keySta[queue][i] = 0;
  58   3                      }else{
  59   3                      }
  60   2              }
  61   1      
  62   1              queue++;
  63   1              queue &= 0x03;
  64   1      }
  65          
  66          void KeyDriver()
  67          {
  68   1              static uint8 pdata keyBuf[4][4]={
  69   1                      {1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1} 
  70   1              };
  71   1              static uint16 ethBuf = 0, enterThreshold = 1000;
  72   1      
  73   1              uint8 i,j;
  74   1      
  75   1              for(i = 0; i < 4; i++)
  76   1              {
  77   2                      for(j = 0; j < 4; j++)
  78   2                      {
  79   3                              if(keyCodeMap[i][j] == 0x26) //长按向上键连续增加
  80   3                              {
  81   4                                      if(keyBuf[i][j] == 0){
  82   5                                              ethBuf += 1;
  83   5                                              if(ethBuf > enterThreshold){
  84   6                                                      KeyAction(0x26);
  85   6                                                      enterThreshold += 100;
  86   6                                              }
  87   5                                      }else{
  88   5                                              ethBuf = 0;
  89   5                                              enterThreshold = 1000;
  90   5                                      }               
  91   4                              }
  92   3      
  93   3                              if(keyBuf[i][j] != keySta[i][j])
  94   3                              {
  95   4                                      if(keyBuf[i][j] == 0x01)
  96   4                                      {
  97   5                                              KeyAction(keyCodeMap[i][j]);
  98   5                                      }
  99   4                                      keyBuf[i][j] = keySta[i][j];
 100   4                              }
 101   3                      }
 102   2              }       
 103   1      }
 104          
 105          void ConfigTimerZero(uint8 ms)
 106          {
 107   1              uint16 tmp;
 108   1      
 109   1              tmp = 65536 - SYS_CLK/1000*ms + 18;
 110   1      
 111   1              T0RH = (uint8)(tmp >> 8);
 112   1              T0RL = (uint8)(tmp & 0x0F);
 113   1      
 114   1              TMOD &= 0xF0;
 115   1              TMOD |= 0x01;
 116   1      
C51 COMPILER V8.08   KEYBOARD                                                              05/31/2017 16:34:26 PAGE 3   

 117   1              TH0 = T0RH;
 118   1              TL0 = T0RL;
 119   1      
 120   1              TR0 = 1;
 121   1              ET0 = 1;
 122   1      }
 123          
 124          void InterruptTimerZero() interrupt 1
 125          {
 126   1              static uint8 cnt200ms = 0, cnt1s = 0, cnt5s = 0;
 127   1      
 128   1              TH0 = T0RH;
 129   1              TL0 = T0RL;
 130   1      
 131   1              cnt200ms++;                     
 132   1              if(cnt200ms >= 200) //200ms定时器
 133   1              {
 134   2                      cnt200ms = 0;
 135   2                      flag200ms = 1;
 136   2                      cnt1s++;                //1s定时器
 137   2                      if(cnt1s >= 5)
 138   2                      {
 139   3                              cnt1s = 0;
 140   3                              flag1s = 1;
 141   3                      }
 142   2                      cnt5s++;
 143   2                      if(cnt5s >= 25)
 144   2                      {
 145   3                              cnt5s = 0;
 146   3                              flag5s = 1;
 147   3                      }
 148   2              }
 149   1              ClearTremble();
 150   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    548    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     48    ----
   DATA SIZE        =     10       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
